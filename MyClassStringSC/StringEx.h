#pragma once
#include <iostream>
#include <string>
/*В классе должны быть:
 
 
 
 
 
 - метод split - разделяет строку на подстроки по символу разделителю ("29/11/2021 года" -> {"29", "11", "2021 года"})
 - метод insert - вставляет заданный текст на позицию ("first".->Insert("second", 3) ==> "firsecondst")
 - метод contains - ищет вхождение подстроки в строке, например "tai" в "contains"*/

class StringEx
{
	//указатель на массив char, хранит символы которые будут передаваться в объект
	char* str;

	//поле хранящее длинну строки
	int length;

public:
	//-конструктор по умолчанию
	//если просто нужно создать объект класса стринг и пока ничего не присваивать

	StringEx()
	{
		str = nullptr;
		length = 0;
	}

    //- конструктор копирования(обязательно!!!)
    StringEx(const char* str)
    {        
        //присвоим значение, которое будет характерезировать колличество символов в строке которую мы присвоили полю length
        length = strlen(str);
                        
        //выделяем место в динамической паяти, +1 для '\0', так как strlen() не учитывает '\0'
        this->str = new char[length + 1];

        //перебираем циклом массивы до тех пор пока в том указателе котрый нам передали в конструкторе есть символы
        // и просто посимвольно их сбрасываем в наш указатель который находится у нас в приват зоне
        for (int i = 0; i < length; i++)
        {
            // проходим по элементам 2х массивов и из одного массива присваиваем поэлементно значения в другой массив
            this->str[i] = str[i];
        }

        //обьявление конца строки
        this->str[length] = '\0';
    }

    //- деструктор, который очистит динамические данные
    //деструктор,отвечает за освобождение ресурсов занятых объектом, вызывается при уничтожении объекта класса
    ~StringEx()
    {
        delete[] this->str;
    }

    //- метод конкатенации
    //оператор + нужен для того чтобы выполнить конкотанацию строки

    //перегрузка оператора сложения который будет возвращать не ссылку, а объект MyString, потому что в результате сложения
    //у нас будет создаваться новый объект которому мы будем присваивать в result

    StringEx operator + (const StringEx& other)
    {
        StringEx newStr;//создаем новый объект класса

        //так как нам нужно знать какого размера будет указатель который будет хранить строку нам будут нужны 2 переменные
        //  когда мы будем выделять место в нашем новом объекте в его указатель str через оператор new 
        //

        //храниит длинну массива чар который в текущей строчке
        int thisLength = strlen(this->str);

        //смотрим сколько места занимает строка которую мы передаем
        int otherLength = strlen(other.str);

        newStr.length = thisLength + otherLength;//присваиваем значение длинны результирующего массива чаров (длины результирующей строки) полю length объекта newStr

        // с помощью оператора new выделяем в нашем новом массиве место равное сумме длин двух массивов плюс 1 так как нужно места для терминирующего нуля
        newStr.str = new char[newStr.length + 1];
        //теперь у нас есть новы массив в котрый мы должны присвоить все элементы из двух массивов из которых мы складываем новую строчку
        //используем два цикла

        //первый цикл переберет массив который находится в this
        //и присвоить в наш новый объект все свои чары 
        int i = 0;//nfr как во втором цикле i должно начинаться не с нуля а с 5го элемента чтобы конечный масиив не перезаписывался а дозаписался
        for (; i < thisLength; i++)
        {
            newStr.str[i] = this->str[i];
        }

        //второй цикл будет помещать обьекты второго массива в новую строку
        //yj мы должны здесь итерироваться с помощью оператора i
        for (int j = 0; j < otherLength; j++, i++)
        {
            newStr.str[i] = other.str[j];
        }
        //после того как все элементы помещены в новый массив, добавляем терминальный ноль для того чтобы обозначить коенец строки
        newStr.str[newStr.length] = '\0';
        //теперь нужно объект который мы создали вернуть как результат работы оператора + (нашей функции)
        return newStr;
    }
};

